// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FRAME_WEBNECT_V1_H_
#define FLATBUFFERS_GENERATED_FRAME_WEBNECT_V1_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace Webnect {
namespace V1 {

struct Color;

struct Point;

struct Pixel;

struct Row;

struct Image;

struct Frame;
struct FrameBuilder;
struct FrameT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Color FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  Color()
      : r_(0),
        g_(0),
        b_(0) {
  }
  Color(uint8_t _r, uint8_t _g, uint8_t _b)
      : r_(::flatbuffers::EndianScalar(_r)),
        g_(::flatbuffers::EndianScalar(_g)),
        b_(::flatbuffers::EndianScalar(_b)) {
  }
  uint8_t r() const {
    return ::flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return ::flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return ::flatbuffers::EndianScalar(b_);
  }
};
FLATBUFFERS_STRUCT_END(Color, 3);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Point FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Point()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Point(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Point, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Pixel FLATBUFFERS_FINAL_CLASS {
 private:
  Webnect::V1::Color color_;
  int8_t padding0__;
  Webnect::V1::Point point_;

 public:
  Pixel()
      : color_(),
        padding0__(0),
        point_() {
    (void)padding0__;
  }
  Pixel(const Webnect::V1::Color &_color, const Webnect::V1::Point &_point)
      : color_(_color),
        padding0__(0),
        point_(_point) {
    (void)padding0__;
  }
  const Webnect::V1::Color &color() const {
    return color_;
  }
  const Webnect::V1::Point &point() const {
    return point_;
  }
};
FLATBUFFERS_STRUCT_END(Pixel, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Row FLATBUFFERS_FINAL_CLASS {
 private:
  Webnect::V1::Pixel pixels_[640];

 public:
  Row()
      : pixels_() {
  }
  Row(::flatbuffers::span<const Webnect::V1::Pixel, 640> _pixels) {
    ::flatbuffers::CastToArray(pixels_).CopyFromSpan(_pixels);
  }
  const ::flatbuffers::Array<Webnect::V1::Pixel, 640> *pixels() const {
    return &::flatbuffers::CastToArray(pixels_);
  }
};
FLATBUFFERS_STRUCT_END(Row, 10240);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Image FLATBUFFERS_FINAL_CLASS {
 private:
  Webnect::V1::Row rows_[480];

 public:
  Image()
      : rows_() {
  }
  Image(::flatbuffers::span<const Webnect::V1::Row, 480> _rows) {
    ::flatbuffers::CastToArray(rows_).CopyFromSpan(_rows);
  }
  const ::flatbuffers::Array<Webnect::V1::Row, 480> *rows() const {
    return &::flatbuffers::CastToArray(rows_);
  }
};
FLATBUFFERS_STRUCT_END(Image, 4915200);

struct FrameT : public ::flatbuffers::NativeTable {
  typedef Frame TableType;
  std::unique_ptr<Webnect::V1::Image> image{};
  uint64_t msvideo = 0;
  uint64_t msdepth = 0;
  FrameT() = default;
  FrameT(const FrameT &o);
  FrameT(FrameT&&) FLATBUFFERS_NOEXCEPT = default;
  FrameT &operator=(FrameT o) FLATBUFFERS_NOEXCEPT;
};

struct Frame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FrameT NativeTableType;
  typedef FrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMAGE = 4,
    VT_MSVIDEO = 6,
    VT_MSDEPTH = 8
  };
  const Webnect::V1::Image *image() const {
    return GetStruct<const Webnect::V1::Image *>(VT_IMAGE);
  }
  uint64_t msvideo() const {
    return GetField<uint64_t>(VT_MSVIDEO, 0);
  }
  uint64_t msdepth() const {
    return GetField<uint64_t>(VT_MSDEPTH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Webnect::V1::Image>(verifier, VT_IMAGE, 4) &&
           VerifyField<uint64_t>(verifier, VT_MSVIDEO, 8) &&
           VerifyField<uint64_t>(verifier, VT_MSDEPTH, 8) &&
           verifier.EndTable();
  }
  FrameT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Frame> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FrameT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameBuilder {
  typedef Frame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_image(const Webnect::V1::Image *image) {
    fbb_.AddStruct(Frame::VT_IMAGE, image);
  }
  void add_msvideo(uint64_t msvideo) {
    fbb_.AddElement<uint64_t>(Frame::VT_MSVIDEO, msvideo, 0);
  }
  void add_msdepth(uint64_t msdepth) {
    fbb_.AddElement<uint64_t>(Frame::VT_MSDEPTH, msdepth, 0);
  }
  explicit FrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Frame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Frame> CreateFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const Webnect::V1::Image *image = nullptr,
    uint64_t msvideo = 0,
    uint64_t msdepth = 0) {
  FrameBuilder builder_(_fbb);
  builder_.add_msdepth(msdepth);
  builder_.add_msvideo(msvideo);
  builder_.add_image(image);
  return builder_.Finish();
}

::flatbuffers::Offset<Frame> CreateFrame(::flatbuffers::FlatBufferBuilder &_fbb, const FrameT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline FrameT::FrameT(const FrameT &o)
      : image((o.image) ? new Webnect::V1::Image(*o.image) : nullptr),
        msvideo(o.msvideo),
        msdepth(o.msdepth) {
}

inline FrameT &FrameT::operator=(FrameT o) FLATBUFFERS_NOEXCEPT {
  std::swap(image, o.image);
  std::swap(msvideo, o.msvideo);
  std::swap(msdepth, o.msdepth);
  return *this;
}

inline FrameT *Frame::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FrameT>(new FrameT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Frame::UnPackTo(FrameT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = image(); if (_e) _o->image = std::unique_ptr<Webnect::V1::Image>(new Webnect::V1::Image(*_e)); }
  { auto _e = msvideo(); _o->msvideo = _e; }
  { auto _e = msdepth(); _o->msdepth = _e; }
}

inline ::flatbuffers::Offset<Frame> Frame::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FrameT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrame(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Frame> CreateFrame(::flatbuffers::FlatBufferBuilder &_fbb, const FrameT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FrameT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _image = _o->image ? _o->image.get() : nullptr;
  auto _msvideo = _o->msvideo;
  auto _msdepth = _o->msdepth;
  return Webnect::V1::CreateFrame(
      _fbb,
      _image,
      _msvideo,
      _msdepth);
}

}  // namespace V1
}  // namespace Webnect

#endif  // FLATBUFFERS_GENERATED_FRAME_WEBNECT_V1_H_
